#include <stdlib.h>
#include <stdio.h>
#include <SDL/SDL.h>
#include <SDL/SDL_image.h>

/*
                                                        AFFICHER DES IMAGES

LA SDL EST UNE BIBLIOTHEQUE TRES SIMPLE. RAPPELONS QUE C'EST UNE BIBLIO DE BAS NIVEAU. CE QUI SIGNIFIE DES FONCTIONS TRES BASIQUES
MAIS QUI PERMETTENT PRATQUEMENT DE TOUT FAIRE EN LES ASSEMBLANT. UN AUTRE AVANTAGE EST LA VITESSE D'EXECUTION PLUS ELEVEE.
LA SDL NE PROPOSE A LA BASE QUE LE CHARGEMENT D'IMAGES DE FORMAT "bitmap" (EXTENSION .bmp). MAIS PAS DE PANIQUE, GRACE A UNE EXTENSION
DE LA SDL (BIBLIO SDL_Image) IL EST POSSIBLE DE CHARGER DE NOMBREUX AUTRES TYPES.

I./ CHARGER UNE IMAGE BMP

1./ FORMAT BMP

LE BITMAP EST UN FORMAT NON COMPRESSEE (CONTRAIREMENT AUX JPG, PNG, GIF, etc.)

TROIS CHOSES EN DECOULENT:
    - LE FICHIER EST TRES RAPIDE A LIRE, CONTRAIREMENT AUX FORMATS COMPRESSEES QUI DOIVENT ETRE DECOMPRESSES, CE QUI PREND UN PEU
    PLUS DE TEMPS
    - LA QUALITE DE L'IMAGE EST PARFAITE. CERTAINS FORMATS COMPRESSES (JPG PLUS PARTICULIEREMENT, CAR PNG ET GIF N'ALTERENT PAS
    L'IMAGE) DETERIORENT LA QUALITE DE L'IMAGE. CE N'EST PAS LE CAS DE BITMAP
    - MAIS LE FICHIER EST AUSSI BIEN PLUS GROS PUISQU'IL N'EST PAS COMPRESSE

POUR LA SDL, L'AVANTAGE EST QUE CE TYPE DE FICHIER EST SIMPLE ET RAPIDE A LIRE. SI J'AI SOUVENT BESOIN DE CHARGER DES IMAGES DANS MON
PROGRAMME, VAUT MIEUX QUE J'UTILISE CE FORMAT LA. CERTES LES FICHIERS SERONT PLUS GROS, MAIS ILS PRENDRONT MOINS DE TEMPS A
CHARGER QU'UN GIF. CELA SE REVELERA UTILE SI MON PROGRAMME DOIT CHARGER BCP D'IMAGES EN PEU DE TEMPS.

2./ CHARGER UN BITMAP

POUR CHARGER UNE IMAGE BMP DANS UNE SURFACE, JE VAIS UTILISER LA FONCTION SDL_LoadBMP.  ELLE S'UTILISE DE FACON TRES SIMPLE:
maSurface=SDL_LoadBMP("image.bmp");
CETTE FONCTION REMPLACE 2 FONCTIONS QUE JE CONNAIS : SDL_CreateRGBSurface et SDL_FillRect. POURQUOI?
==>LA TAILLE A ALLOUER EN MEMEOIRE POUR LA SURFACE DEPEND DE LA TAILLE DE L'IMAGE
==>D'AUTRE PART, MA SURFACE SERA REMPLIE PIXEL PAR PIXEL PAR LE CONTENU DE MON IMAGE BMP

ATTENTION, IL NE FAUT PAS OUBLIER DE BLITTER L'IMAGE SUR L'ECRAN UNE FOIS QU'ON L'A CHARGE EN MEMOIRE.

3./ASSOCIER UNE ICONE A SON APPLICATION

MON ICONE DOIT NORMALEMENT ETRE DE TAILLE 16x16 px. TOUTEFOIS, SOUS WINDOWS, ELLE DOIT ETRE DE TAILLE 32x32 px, SINON ELLE SERA
DEFORMEE. MAIS PAS DE PANIQUE, LA SDL "REDUIRA" LES DIMENSIONS DE L'IMAGE POUR QU'ELLE RENTRE DANS 16x16 px.

POUR AJOUTER L'ICONE A LA FENETRE, ON UTILISE LA FONCTION SDL_WM_SetIcon.
==> 2 P :
    - LA SURFACE QUI CONTIENT L'IMAGE A AFFICHER
    - INFORMATIONS RELATIVES A LA TRANSPARENCE (NULL SI JE NE VEUX PAS DE TRANSPARENCE)

Remarque : La gestion de la transparence d'une icone est un peu compliquee (Il faut preciser un a un quels sont les pixels
        transparents). Je ne l'etudierai donc pas ici (ou ailleurs).

JE COMBINE DEUX FONCTIONS EN UNE:
SDL_WM_SetIcon(SDL_LoadBMP("sdl_icone.bmp"), NULL);
L'IMAGE EST CHARGEE EN MEMOIRE PAR SDL_LoadBMP ET L'ADRESSE DE L'IMAGE EST DIRECTEMENT ENVOYEE A SDL_WM_SetIcon

ATTENTION: LA FONCTION SDL_WM_SetIcon DOIT ETRE APPELEE AVANT QUE LE FENETRE NE SOIT OUVERTE. C-A-D QU'ELLE DOIT SE TROUVER
AVANT SDL_SetVideoMode DANS MON CODE SOURCE

4./ GESTION DE LA TRANSPARENCE
LORLSQUE JE BLITTE UNE IMAGE SUR LE FOND, MON IMAGE ETANT RECTANGULAIRE, ON VOIT LE FOND DE CELUI-CI ET GENERALEMENT CA REND
PAS TRES BIEN. IL FAUT ALORS RENDRE LE FOND DE L'IMAGE TRANSPARENT.
APRES, ON PEUT AUSSI SE DEMANDER COMMENT RENDRE TOUTE L'IMAGE MOINS OPAQUE...
a.) RENDRE LE FOND D'UNE IMAGE TRANSPARENT
    ETAPE 1 : PREPARER L'IMAGE
LE FORMAT BMP NE GERE PAS LA TRANSPARENCE. IL VA FALLOIR RECOURIR A UNE ASTUCE
==> COLORIER DE LA MEME COULEUR LE FOND DE L'IMAGE, DE MANIERE A CE QUE CETTE COULEUR SOIT UNIQUE (i.e. exclusive) ET UNIE.

    ETAPE 2 : INDIQUER LA COULEUR TRANSPARENTE
==> ON A RECOURS A LA FONCTION SDL_SetColorKey
    SDL_SetColorKey(zozor, SDL_SRCCOLORKEY, SDL_MapRGB( zozor->format, 0, 0, 255);
    C'EST UNE FCT AVEC 3 PARAMETRES:
            - LA SURFACE QUI DOIT ETRE RENDUE TRANSPARENTE(ici c'est zozor)
            - UNE LISTE DE FLAGS : SDL_SRCCOLORKEY POUR ACTIVER LA TRANSPARENCE, 0 POUR DESACTIVER
            - LA COULEUR QUI DOIT ETRE RENDUE TRANSPARENTE. (ici le bleu pur)

    ATTENTION, IL FAUT BLITTER SEULEMENT APRES AVOIR APPELE CETTE FONCTION, PAS AVANT

b.) LA TRANSPARENCE ALPHA

JUSQU'ICI, JE ME CONTENTAIS DE DEFINIR UNE SEULE COULEUR TRANSPARENTE. CETTE DERNIERE N'APPARAISSANT PAS UNE FOIS L'IMAGE BLITTEE.
LA TRANSPARENCE ALPHA PERMET DE REALISER UN MELANGE ENTRE UNE IMAGE ET LE FOND. C'EST UNE SORTE DE FONDU.
LA TRANSPARENCE ALPHA D'UNE SURFACE PEUT ETRE ACTIVEE PAR LA FONCTION SDL_SetAlpha. CELLE-CI ACCEPTE AUSSI 3 PARAMETRES
==>    SDL_SetAlpha(zozor, SDL_SRCALPHA, 128)
LES 3 P :
        - LA SURFACE EN QUESTION
        - UNE LISTE DE FLAGS : SDL_SRCALPHA POUR ACTIVER LA TRANSPARENCE, 0 POUR DESACTIVER
        - LA VALEUR ALPHA DE LA TRANSPARENCE. C'EST UN NOMBRE COMPRIS ENTRE 0 (TOTLMT TRANSPARENT) ET 255 (TOTLMT OPAQUE)

REMARQUE : LA TRANSPARENCE ALPHA 128 (TRANSPARENCE MOYENNE) EST UNE VALEUR SPECIALE QUI EST OPTIMISEE PAR LA SDL. CE TYPE DE
VALEUR EST PLUS RAPIDE A CALCULER QUE LES AUTRES. BON A SAVOIR SI J'UTILISE BCP DE TRANSPARENCE DANS MON PROGRAMME.

II./CHARGER PLUS D'IMAGES AVEC LA SDL_Image

MEME SI LE BMP EST PLUS RAPIDE A CHARGER, AUJOURD'HUI ON A PLUS L'HABITUDE D'UTILISER D'AUTRES FORMATS, NOTAMMENT LE PNG, LE GIF
ET LE JPEG. CA TOMBE BIEN. IL EXISTE JUSTEMENT UNE BIBLIO SDL_Image QUI GERE TOUS LES FORMATS SUIVANTS:
.TGA ;
.BMP ;
.PNM ;
.XPM ;
.XCF ;
.PCX ;
.GIF ;
.JPG ;
.TIF ;
.LBM ;
.PNG

IL EST EN FAIT POSSIBLE DE RAJOUTER DES EXTENSIONS A LA SDL. CE SONT DES BIBLIO QUI ONT BESOIN DE LA SDL POUR EXISTER. ON PEUT
VOIR CA COMME DES add-ons (ON EMPLOIE AUSSI PARFOIS LE MOT greffon, PLUS FRANCAIS). SDL_Image EST L'UNE D'ELLES.
1./ INSTALLATION

a.)TELECHARGEMENT
Télécharger la version de SDL_Image qui me correspond dans la section Binary (PAS la source, on n'en a pas besoin !).
 Sous Windows, télécharger SDL_image-devel-1.2.10-VC.zip, et ce même si je n'utilise pas Visual C++ !

b.)Installation

Dans ce .zip, vous trouverez :

- SDL_image.h : le seul header dont a besoin la bibliothèque SDL_Image. Le placer dans C:\Program Files\CodeBlocks\SDL-1.2.13\include,
 c'est-à-dire à côté des autres headers de la SDL ;

- SDL_image.lib : copier dans C:\Program Files\CodeBlocks\SDL-1.2.13\lib.  Ici exceptionnellement le .lib fonctionnera même avec
 le compilateur mingw ;
- plusieurs DLL : a placer dans le dossier de mon projet (à côté de SDL.dll, donc).

c.)Terminer l'installation

Dans le menu Projects / Build options. Dans l'onglet Linker, cliquez sur le bouton Add et indiquez où se trouve le fichier
SDL_image.lib

2./ CHARGER LES IMAGES

IL Y A UNE SEULE FONCTION A CONNAITRE : IMG_Load. ELLE PREND UN PARAMETRE : LE NOM DU FICHIER A OUVRIR. ELLE
DETECTERA TOUTE SEULE LE TYPE DU FICHIER EN FONCTION DE SON EXTENSION.

JE PEUX MEME OUBLIER (ou pas) SDL_LoadBMP ET N'UTILISER PLUS QUE IMG_Load POUR CHARGER N'IMPORTE QUELLE IMAGE.
AUTRE BON POINT: SI L'IMAGE QUE JE CHARGE GERE LA TRANSPARENCE (COMME C'EST LE CAS DES PNG ET DES GIF), ALORS
SDL_image ACTIVERA AUTOMATIQUEMENT LA TRANSPARENCE POUR CETTE IMAGE. CELA M'EVITE DONC D'APPELER SDL_SetColorKey.

*/

void pause();

int main ( int argc, char** argv )
{
    SDL_Surface *ecran=NULL, *imageDeFond=NULL, *zozor=NULL, *sapin=NULL;
    SDL_Rect positionFond, positionZozor, positionSapin;

    positionFond.x=0;
    positionFond.y=0;

    positionZozor.x=500;
    positionZozor.y=260;

    positionSapin.x=620;
    positionSapin.y=240;



    if(SDL_Init(SDL_INIT_VIDEO)==-1)
        {
            fprintf(stderr, "Erreur d'initialisation : %s\n", SDL_GetError());
            exit(EXIT_FAILURE);
        }
    SDL_WM_SetIcon(SDL_LoadBMP("images/sdl_icone.bmp"), NULL); // !!!!!!!! 1ER P: SURFACE QUI CONTIENT L'IMAGE!!!!
    ecran=SDL_SetVideoMode(800, 600, 32, SDL_HWSURFACE);
    SDL_WM_SetCaption("Chargement d'images en SDL", NULL);

    imageDeFond=SDL_LoadBMP("images/lac_en_montagne.bmp");
    SDL_BlitSurface(imageDeFond, NULL, ecran, &positionFond);
    //CHARGEMENT ET BLITTAGE DE ZOZOR SUR LA SCENE
    zozor=SDL_LoadBMP("images/zozor.bmp");
    //ON REND LE BLEU DERRIERE ZOZOR TRANSPARENT
    SDL_SetColorKey(zozor, SDL_SRCCOLORKEY, SDL_MapRGB(zozor->format, 0, 0, 255));
    SDL_SetAlpha(zozor, SDL_SRCALPHA, 220);
    SDL_BlitSurface(zozor, NULL, ecran, &positionZozor);

    sapin=IMG_Load("images/sapin.png");//la transparence du fond est gere automatiquement pour PNG
    SDL_BlitSurface(sapin, NULL, ecran, &positionSapin);
    SDL_Flip(ecran);
    pause();
    SDL_FreeSurface(imageDeFond);
    SDL_FreeSurface(zozor);
    SDL_Quit();
    return EXIT_SUCCESS;
}

void pause()
{
    int continuer=1;
    SDL_Event event;

    while(continuer)
    {
        SDL_WaitEvent(&event);
        switch(event.type)
        {
            case SDL_QUIT:
                continuer = 0;

        }

    }
}
