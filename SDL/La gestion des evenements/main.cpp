#include <stdlib.h>
#include <stdio.h>
#include <SDL/SDL.h>

/*
                                                    LA GESTION DES EVENEMENTS

INTRO : QU'EST-CE QU'UN EVENEMENT? C'EST UN "SIGNAL" ENVOYE PAR UN PERIPHERIQUE (OU PAR L'OS)A MON APPLICATION. VOICI QUELQUES
EXEMPLES COURANTS :
    -   quand l'utilisateur appuie sur une touche du clavier ;
    -   quand il clique avec la souris ;
    -   quand il bouge la souris ;
    -   quand il réduit la fenêtre ;
    -   quand il demande à fermer la fenêtre ;
    -   etc.

I./ LE PRINCIPE DES EVENEMENTS

1.) LA VARIABLE D'EVENEMENT

POUR TRAITER DES EVENEMNTS, J'AI BESOIN DE DECLARER UNE (ET UNE SEULE) VARIABLE, DE TYPE SDL_Event.
PAR EXEMPLE: SDL_Event event;

2.) LA BOUCLE DES EVENEMENTS

LORSUQU'ON VEUT ATTENDRE UN EVENEMENT, ON FAIT GENERALEMENT UNE BOUCLE QUI SE REPETERA TANT QU'ON N'A PAS EU L'EVENEMENT VOULU.
D'OU LE BESOIN D'UN BOLEEN QUI INDIQUERA SI ON DOIT CONTINUER LA BOUCLE OU NON.
APPELONS LE : int continuer = 1;
DES QUE CETTE VARIABLE VAUDRA 0 (FAUX), ALORS ON SORTIRA DE LA BOUCLE ET LE PROGRAMME S'ARRETERA.
VOICI LA BOUCLE A CREER:
while(continuer)
{
    //TRAITEMENT DES EVENEMENTS

}
3.) RECUPERATION DE L'EVENEMENT

MAINTENANT FAISONS APPEL A UNE FONCTION DE LA SDL POUR DEMANDER SI UN EVENT S'EST PRODUIT.
ON DISPOSE DE DEUX FONCTIONS QUI FONT CA, MAIS CHACUNE A SA MANIERE:
    -   SDL_WaitEvent : ELLE ATTEND QU'UN EVENEMNT SE PRODUISE. ELLE EST DITE BLOQUANTE CAR ELLE SUSPEND L'EXECUTION DE
    L'APPLICATION TANT QU'AUCUN EVENEMENT NE S'EST PRODUIT.
    -   SDL_PollEvent : CETTE FCT FAIT LA MEME CHOSE MAIS N'EST PAS BLOQUANTE. ELLE ME DIT SI UN EVENT S'EST PRODUIT OU NON.
    MEME SI AUCUN EVENT NE S'EST PRODUIT, ELLE REND LA MAIN A MON PROGRAMME DE SUITE.

LEUR UTILITE EST RELATIVE SUIVANT LE CAS.
POUR FAIRE SIMPLE : SI J'UTILISE SDL_WaitEvent, MON PROCESSER UTILISERA TRES PEU DE PROCESSEUR CAR IL ATTENDRA QU'UN EVENT
SE PRODUISE (EXPLICATION : LE PROCESSUS DE MON PROGRAMME SERA MIS EN "PAUSE" ET SERA "REVEILLE" PAR L'OS AU MOMENT OU IL Y
             AURA UN EVENT)
EN REVANCHE, SI J'UTILISE SDL_PollEvent, MON PROGRAMME VA PARCOURIR LA BOUCLE while ET RAPPELER SDL_PollEvent INDEFINIMENT JUSQU'A
CE QU'UN EVENT SE SOIT PRODUIT. A TOUS LES COUPS, J'UTILISE 100 % DU PROCESSEUR.
CONTRAIREMENT A CE QU'ON PEUT PENSER, SDL_PollEvent SE REVELE INDISPENSABLE, NOTAMMENT LORSQUE L'ECRAN DOIT SE METTRE A JOUR
MEME S'IL N'Y A AUCUN EVENT (EXEMPLE: DANS LE TETRIS, LES BLOCS DESCENDENT TOUT SEULS, SANS QU'IL Y AIT BESOIN QUE L'UTILISATEUR
CREE UN EVENT POUR CA. AVEC SDL_WaitEvent LE PROG SERAIT RESTE BLOQUE DS CETTE FCT ET J'AURAI PAS PU METTRE A JOUR L'ECRAN POUR
FAIRE DESCENDRE LES BLOCS!)

POUR LE MOMENT, J'UTILISERAI SDL_WaitEvent CAR MON PROG RESTE TRES SIMPLE. LES 2 FCTS DE TTE FACON S'UTILISENT DE LA MEME MANIERE.
JE DOIS ENVOYER A LA FCT L'ADRESSE DE MA VARIABLE event QUI STOCKE L'EVENEMENT.
COMME CETTE VARIABLE N'EST PAS UN POINTEUR, JE METS UN & DEVANT LE NOM DE LA VARIABLE:
SDL_WaitEvent(&event);
APRES APPEL DE CETTE FCT, LA VARIABLE event CONTIENT OBLIGATOIREMENT UN EVENEMENT.
CELA N'AURAIT PAS ETE LE CAS AVEC SDL_PollEvent : CAR CELLI-CI AURAIT PU RENVOYER "PAS D'EVENEMENT".

4.) ANALYSE DE L'EVENEMENT

MA VARIABLE event CONTIENT DES INFO SUR L'EVENT QUI S'EST PRODUIT.
IL FO REGARDER LA SOUS-VARIABLE event.type ET FAIRE UN TEST SUR SA VALEUR ==> GNRLMNT ON UTILISE UN switch POUR TESTER L'EVENT.

LA SDL NOUS FOURNIT AUTANT DE CONSTANTES QUE D'EVENTS POSSIBLES, CE QUI SIMPLIFIE BCP L'ECRITURE DU PROG.
AINSI, LA VALEUR SDL_QUIT CORRESPOND A L'EVENT "Quitter".
FCTMNT:
    i) DES QU'IL Y A UN EVENT, LA FCT SDL_WaitEvent RENVOIE CET EVENT DANS event
    ii) ON ANALYSE LE TYPE D'EVENT GRACE A switch. LE TYPE D'EVENT SE TROUVE DANS event.type
    iii) ON TESTE A L'AIDE DE case DANS LE switch LE TYPE D'EVENT. POUR LE MOMENT ON NE TESTE QUE L'EVENT SDL_QUIT (DEMANDE DE FERMETURE DE PROG)
        CAR C'EST LE SEUL QUI NOUS INTERESSE
    iv) SI C'EST UN EVENT SDL_QUIT, C'EST QUE L'UTILISATEUR A DEMANDE LA FERMETURE DU PROG. DANS CE CAS, LE BOLEEN SE MET A 0. AU
        PROCHAIN TOUR DE LA BOUCLE, LA CONDITION SERA FAUSSE ET DONC LA BOUCLE S'ARRETERA. LE PROG S'ARRETERA ENSUITE.
    v) SI C'EST PAS UN EVENT SDL_QUIT, C'EST QU'IL S'EST PASSE AUTRE CHOSE : L'UTILISATEUR A APPUYE SUR UNE TOUCHE, A CLIQUE OU TOUT
        SIMPLEMENT BOUGE LA SOURIS DANS LA FENETRE. COMME CES EVENTS LA NOUS INTERESSENT PAS, ON LES TRAITE PAS. ON NE FAIT DONC RIEN,
        LA BOUCLE RECOMMENCE ET ON ATTEND A NOUVEAU UN EVENT (ON REPART A LA 1RE ETAPE)

IL VAUT MIEUX METTRE CE CODE DANS UNE FCT A PART (pause()).

II./ LE CLAVIER

1.) LES EVENTS DU CLAVIER

IL EXISTE 2 EVENTS DIFFERENTS QUI PEUVENT ETRE GENERES PAR LE CLAVIER:

    -   SDL_KEYDOWN : QUAND UNE TOUCHE DU CLAVIER EST ENFONCEE
    -   SDL_KEYUP : QUAND UNE TOUCHE DU CLAVIER EST RELACHEE

LA SDL ME PERMET DE TRAITER CES 2 FCT A PART, CE QUI SERA BIEN PRATIQUE.
EXEMPLE.

2.) RECUPERER LA TOUCHE

IL SE REVELE PARFOIS UTILE DE SAVOIR LAQUELLE DES TOUCHES EST ENFONCEE.
ON PEUT OBTENIR LA NATURE DE LA TOUCHE ENFONCEE GRACE A UNE SOUS-SOUS-SOUS-VARIABLE QUI S'APPELLE:
event.key.keysym.sym    : CETTE VARIABLE CONTIENT LA VALEUR DE LA TOUCHE QUI A ETE ENFONCEE (ELLE FONCTIONNE AUSSI LORS D'UN
                         RELACHEMENT DE LA TOUCHE SDL_KEYUP)
L'AVANTAGE, C'EST QUE LA SDL PERMET AINSI DE RECUPERER LA VALEUR DE TOUUUTES LES TOUCHES DU CLAVIER (Y COMPRIS Echap, Suppr., etc.)
IL Y A UNE CONSTANTE POUR CHACUNE DES TOUCHES DU CLAVIER : JE PEUX LES TROUVER DANS LA SECTION "Keysym definitions" DE LA
DOCUMENTATION DE LA SDL OU ALORS SUR LE WEB.

REMARQUE : CERTAINES TOUCHES, COMME Maj (ou Shift) N'ONT PAS DE VALEUR ASCII CORRESPONDANTES.

EXEMPLE : ON PEUT VERIFIER SI LA TOUCHE Echap EST ENFONCEE GRACE A LA CONSTANTE SDLK_ESCAPE COMME CECI
J'AURAIS PU UTILISER UN if, MAIS UN switch CONVIENT MIEUX CAR SOUVENT ON GERE BCP D'EVENTS

MAINTENANT QUE JE SAIS SORTIR DU PROG EN APPUYANT SUR Echap, JE PEUX EN TOUTE SERENNITE BASCULER VERS LE MODE PLEIN ECRAN

III./ EXERCICE : DIRIGER zozor AU CLAVIER

C'EST LE B.A.-BA

1.) CHARGER L'IMAGE

Je dois initialiser positionZozor après avoir chargé les surfaces ecran et zozor. En effet, j'utilise la largeur (w) et la
hauteur (h) de ces deux surfaces pour calculer la position centrée de Zozor à l'écran, il faut donc que ces surfaces aient été
initialisées auparavant

2.) SCHEMA DE LA PROGRAMMATION EVENEMENTIELLE

QUAND JE CODE UN PROGRAMME QUI REAGIT AUX EVENTS, JE DOIS SUIVRE LA PLUPART DU TEMPS LE MEME SCHEMA DE CODE.
CE SCHEMA EST A CONNAITRE PAR COEUR:

while(continuer)
{
    SDL_WaitEvent(&event);
    switch(event.type)
    {
        case SDL_Truc: //GESTION DES EVENTS DE TYPE TRUC
        case SDL_Bidule: //GESTION DES EVENTS DE TYPE BIDULE
    }
    //ON EFFACE L'ECRAN (ici fond blanc):
    SDL_FillRect(ecran, NULL, SDL_MapRGB(ecran->format, 255, 255, 255);
    //ON FAIT TOUS LES SDL_BlitSurface NECCESSAIRES POUR COLLER LES SURFACES A L'ECRAN

    //ON MET A JOUR L'AFFICHAGE:
    SDL_Flip(ecran);
}

AINSI, UNE FOIS SORTI DU (GRAND) switch, ON PREPARE UN NOUVEL AFFICHAGE :
    i/ PREMIERE CHOSE A FAIRE : ON EFFACE L'ECRAN AVEC UN SDL_FillRect POUR QU'IL NE RESTE PAS DE "TRACES" DE L'ANCIEN ECRAN
    ii/ ENSUITE, ON FAIT TOUS LES BLITS NECESSAIRES POUR COLLER LES SURFACES A L'ECRAN
    iii/ ENFIN, UNE FOIS QUE C'EST FAIT, ON MET A JOUR L'AFFICHAGE AUX YEUX DE L'UTILISATEUR, EN APPELANT LA FCT SDL_Flip(ecran)

3.) TRAITER L'EVENT SDL_KEYDOWN

MON BUT EST DE DIRIGER zozor AVEC LES FLECHES DIRECTIONNELLES. JE VAIS DONC MODIFIER SES COORDONNEES EN FCT DE LA FLECHE SUR
LAQUELLE J'APPUIE

4.) QUELQUES OPTIMISATIONS

a./ REPETITION DES TOUCHES

LA FCT SDL_EnableKeyRepeat PERMET D'ACTIVER LA REPETITION DES TOUCHES. ELLE FAIT EN SORTE QUE LA SDL REGENERE UN EVENT DE TYPE
SDL_KEYDOWN SI UNE TOUCHE EST MAINTENUE ENFONCEE UN CERTAIN TEMPS.
CETTE FCT PEUT ETRE APPELEE QUAND JE VEUX, MAIS IL EST PREFERABLE DE L'APPELER AVANT LA BOUCLE PRINCIPALE DU PROG.
ELLE PREND 2 PARAMETRES :
    -   LA DUREE (EN MILLISECONDES) PENDANT LAQUELLE UNE TOUCHE DOIT RESTER ENFONCEE AVANT D'ACTIVER LA REPETITION DES TOUCHES
    -   LE DELAI (EN MILLISECONDES) ENTRE CHAQUE GENERATION D'UN EVENT SDL_KEYDOWN UNE FOIS QUE LA REPETITION A ETE ACTIVEE

POUR DES RAISONS DE FLUIDITE, JE METTRAI LA MEME VALEUR A CES DEUX EVENTS.

b./ TRAVAILLER AVEC LE DOUBLE BUFFERING

LA TECHNIQUE DU DOUBLE BUFFERING CONSISTE A UTILISER DEUX ECRANS, L'UN QUI EST REEL (CELUI QUE L'UTILISATEUR VOIT SUR SON MONITEUR),
ET L'AUTRE QUI EST VIRTUEL (C'EST UNE IMAGE QUE L'ORDINATEUR EST EN TRAIN DE CONSTRUIRE EN MEMOIRE).

C'EST MIEUX (MEME SI ICI CA NE SE VOIT PAS TROP) CAR IL N'Y A AUCUN SCINTILLEMENT QUAND ON FAIT BOUGER LES IMAGES.

III./ LA SOURIS

LA SOURIS PEUT GENERER TROIS TYPES D'EVENTS DIFFERENTS:
    -   SDL_MOUSEBUTTONDOWN : CELA CORRESPOND AU MOMENT OU LE BOUTON DE LA SOURIS EST ENFONCE
    -   SDL_MOUSEBUTTONUP : LORSQU'ON RELACHE LE BOUTON DE LA SOURIS. MEME PRINCIPE QUE POUR LE CLAVIER DONC
    -   SDL_MOUSEMOTION : LORSQU'ON DEPLACE LE CURSEUR DE LA SOURIS. A CHAQUE FOIS QUE LA SOURIS BOUGE DANS LE FENETRE (NE
                        SERAIT-CE QUE D'UN PIXEL), UN EVENT SDL_MOUSEMOTION EST GENERE.

JE TRAVAILLERAI ICI AVEC SDL_MOUSEBUTTONUP. LE PRINCIPE EST DE TOUTE FACON LE MEME POUR SDL_MOUSEBUTTONDOWN.

1.) GERER LES CLICS DE LA SOURIS

JE VAIS DONC CAPTURER UN EVENT DE TYPE SDL_MOUSEBUTTONUP (clic de la souris) PUIS VOIR QUELLES INFORMATIONS ON PEUT RECUPERER.

IL Y A DEUX INFORMATIONS QUE L'ON PEUT RECUPERER LORS D'UN CLIC DE LA SOURIS :
    -   LE BOUTON DE LA SOURIS AVEC LEQUEL ON A CLIQUE (CLIC GAUCHE? CLIC DROIT? CLIC BOUTON DU MILIEU?)
    -   LES COORDONNEES DE LA SOURIS AU MOMENT DU CLIC (x ET y)

2.) RECUPERER LE BOUTON DE LA SOURIS

ON VA D'ABORD VOIR AVEC QUEL BOUTON DE LA SOURIS ON A CLIQUE. POUR CELA IL FO ANALYSER LA SOUS-VARIABLE event.bouton.button ET
COMPARER SA VALEUR AVEC L'UNE DES 5 CONSTANTES SUIVANTES :
    -   SDL_BUTTON_LEFT
    -   SDL_BUTTON_RIGHT
    -   SDL_BUTTON_MIDDLE (CLIC AVEC LA MOLETTE)
    -   SDL_BUTTON_WHEELUP (MOLETTE DE LA SOURIS VERS LE HAUT)
    -   SDL_BUTTON_WHEELDOWN (MOLETTE DE LA SOURIS VERS LE BAS)
AINSI -->

3.) RECUPERER LES COORDONNEES DE LA SOURIS

ON RECUPERE LES COORDONNEES DE LA SOURIS AU MOMEMENT DU CLIC GRACE AUX DEUX VARIABLES :
    -   event.button.x
    -   event.button.y

JE VAIS BLITTER ZOZOR A L'ENDROIT DU CLIC DE LA SOURIS

4.) GERER LE DEPLACEMENT DE LA SOURIS

UN DEPLACEMENT DE LA SOURIS GENERE UN EVENT DE TYPE SDL_MOUSEMOTION.
ON GENERE AUTANT D'EVENTS QUE L'ON PARCOURT DE PIXELS POUR SE DEPLACER. PAR EXEMPLE, SI JE BOUGE LA SOURIS DE 100 PIXELS, IL Y
AURA 100 EVENTS GENERES.
VOILA COMMENT JE PEUX RECUPERER LES COORDONNEES DE LA SOURIS, QUI CONSTITUENT LA SEULE INFORMATION QUI EN DECOULE :
    -   event.motion.x
    -   event.motion.y
ATTENTION, A NE PAS CONFONDRE AVEC event.button.x et ..y

AINSI, JE VAIS PLACER ZOZOR AUX MEMES COORDONNEES QUE LA SOURIS

5.) QUELQUES AUTRES FCTS DE LA SOURIS

a./ MASQUER LA SOURIS

POUR MASQUER LE CURSEUR DE LA SOURIS, IL SUFFIT D'APPELER LA FCT SDL_ShowCursor ET DE LUI ENVOYER UN FLAG :
    -   SDL_DISABLE : MASQUE LE CURSEUR DE LA SOURIS (TANT QU'IL SERA A L'INTERIEUR DE LA FENETRE)
    -   SDL_ENABLE : REAFFICHE LE CURSEUR DE LA SOURIS

IL VAUT MIEUX MASQUER LE CURSEUR AVANT LA BOUCLE PRINCIPALE

b./ PLACER LA SOURIS A UN ENDROIT PRECIS

ON PEUT PLACER MANUELLEMENT LE CURSEUR DE LA SOURIS AUX COORDONNEES QUE L'ON VEUT DANS LE FENETRE.
ON UTILISE POUR CELA SDL_WarpMouse QUI PREND POUR PARAMETRES x ET y OU LE CURSEUR DOIT ETRE PLACE.
PAR EXEMPLE, LE CODE SUIVANT PLACE LA SOURIS AU CENTRE DE L'ECRAN:
SDL_WarpMouse(ecran->w / 2, ecran->h / 2);

REMARQUE : LORSQUE JE FAIS UN SDL_WarpMouse, UN EVENT SDL_MOUSEMOTION EST GENERE.

IV./ LES EVENTS DE LA FENETRE

LA FENETRE ELLE-MEME PEUT GENERER UN CERTAIN NB D'EVENTS :
    -   LORSQU'ELLE EST REDIMENSIONNEE
    -   LORSQU'ELLE EST REDUITE EN BARRE DES TACHES OU RESTAUREE
    -   LORSQU'ELLE EST ACTIVE (AU PREMIER PLAN) OU LORSQU'ELLE N'EST PAS ACTIVE
    -   LORSQUE LE CURSEUR DE LA SOURIS SE TROUVE A L'INTERIEUR DE LA FENETRE OU LORSQU'IL EN SORT

1.) REDIMENSIONNEMENT DE LA FENETRE

RAPPEL : FLAG SDL_RESIZABLE A ACTIVER DANS SDL_SetVideoMode
JE REDIMENSIONNE LA FENETRE ==> UN EVENT DE TYPE SDL_VIDEORESIZE EST GENERE
==> JE PEUX RECUPERER :
    -   LA NOUVELLE LARGEUR DANS event.resize.w
    -   LA NOUVELLE HAUTEUR DANS event.resize.h

ON PEUT UTILISER CES INFO POUR FAIRE EN SORTE QUE ZOZOR SOIT TOUJOURS CENTRE DANS LA FENETRE

2.) VISIBILITE DE LA FENETRE

L'EVENT SDL_ACTIVEEVENT EST GENERE LORSQUE LA VISIBILITE DE LA FENETRE CHANGE. CELA PEUT ETRE DU A DE NBREUSES CHOSES :
    -   LA FENETRE EST REDUITE EN BARRE DES TACHES OU RESTAUREE;
    -   LE CURSEUR DE LA SOURIS SE TROUVE A L'INTERIEUR DE LA FENETRE OU EN SORT;
    -   LA FENETRE EST ACTIVEE OU N'EST PLUS ACTIVE

NOTE : EN PROGRAMMATION, ON PARLE DE FOCUS. LORSQU'ON DIT QU'UNE APPLICATION A LE FOCUS, C'EST QUE LE CLAVIER OU LA SOURIS DE
L'UTILISATEUR S'Y TROUVE. TOUS LES CLICS SUR LA SOURIS OU APPUIS SUR LES TOUCHES DU CLAVIER QUE JE FAIS SONT ENVOYES A LA FENETRE
QUI A LE FOCUS ET NON AUX AUTRES. UNE SEULE FENETRE PEUT AVOIR LE FOCUS A UN INSTANT DONNE.

ETANT DONNE LE NB DE RAISONS QUI PEUVENT AVOIR PROVOQUE CET EVENT, IL FO ABSOLUMENT REGARDER DANS DES VARIABLES POUR EN SAVOIR
PLUS :
    -   event.active.gain : INDIQUE SI L'EVENT EST UN GAIN (1) OU UNE PERTE (0). PAR EXEMPLE, SI LA FENETRE EST PASSEE EN
            ARRIERE-PLAN, C'EST UNE PERTE, SI ELLE EST REMISE AU 1ER PLAN C'EST UN GAIN.
    -   event.active.state : C'EST UNE COMBINAISON DE FLAGS INDIQUANT LE TYPE D'EVENT QUI S'EST PRODUIT. VOICI LA LISTE DES
            FLAGS POSSIBLES :
                ==> SDL_APPMOUSEFOCUS : LE CURSEUR DE LA SOURIS VIENT DE RENTRER OU DE SORTIR DE LA FENETRE (IL FO REGARDER LA
                    VALEUR event.active.gain POUR SAVOIR SI ELLE EST RENTREE OU SORTIE)
                ==> SDL_APPINPUTFOCUS : L'APPLI VIENT DE RECEVOIR LE FOCUS DU CLAVIER OU DE LE PERDRE. CA SIGNIFIE EN FAIT QUE MA
                    FENETRE VIENT D'ETRE MISE AU PREMIER PLAN OU EN ARRIERE-PLAN (IL FO REGARDER LA VALEUR DE event.active.gain...)
                ==> SDL_APPACTIVE : L'APPLI A ETE ICONIFIEE, C-A-D REDUITE DANS LA BARRE DES TACHES (gain=0), OU REMISE DANS SON
                    ETAT NORMAL (gain=1)

    3.) TESTER LA VALEUR D'UNE COMBINAISON DE FLAGS

event.active.state EST UNE COMBINAISON DE FLAGS. CELA SIGNIFIE QUE DANS UN EVENT, IL PEUT SE PRODUIRE DEUX CHOSES A LA FOIS (PAR
EXEMPLE, SI ON REDUIT LA FENETRE A LA BARRE DES TACHES, ON PERD AUSSI LE FOCUS DU CLAVIER ET DE LA SOURIS)
IL VA DONC FALLOIR FAIRE UN TEST (UN PEU PLUS COMPLIQUE QUE SIMPLE)
if(event.active.state==SDL_APPACTIVE)
J'AI DIT COMPLIQUE CAR C'EST UNE COMBINAISON DE BITS, SANS ENTRER DANS LES DETAILS ICI.
VOICI LE CODE QU'IL FO UTILISER POUR TESTER SI UN FLAG EST PRESENT DANS UNE VARIABLE :
if((event.active.state & SDL_APPMOUSEFOCUS) == SDL_APPMOUSEFOCUS)
PAS D'ERREUR ICI, IL Y A BIEN 1 SEUL '&' ET 2 '='.
CELA FONCTIONNE DE LA MEME MANIERE POUR LES AUTRES EVENTS, PAR EX :
if((event.active.state & SDL_APPACTIVE) == SDL_APPACTIVE)

    4.) TESTER L'ETAT ET LE GAIN A LA FOIS

EN TESTANT L'ETAT ET LE GAIN A LA FOIS, JE PEUX SAVOIR EXACTEMENT CE QUI S'EST PASSE.
SUPPOSONS QUE J'AI UN JEU QUI FAIT FAIRE BCP DE CALCULS A L'ORDINATEUR. JE VEUX QUE LE JEU SE METTE EN PAUSE LORSQUE LA FENETRE
 EST REDUITE, ET QU'IL SE RELANCE LORSQUE LA FENETRE EST RESTAUREE.

LE CODE CI-DESSOUS MET EN PAUSE LE JEU EN ACTIVANT UN BOLEEN pause A 1. IL REMET EN MARCHE LE JEU EN DESACTIVANT LE BOLEEN A 0 :

if((event.active.state & SDL_APPACTIVE) == SDL_APPACTIVE)
{
    if(event.active.gain == 0) // LA FENETRE A ETE REDUITE
        pause = 1;
    else if(event.active.gain == 1) // LA FENETRE A ETE RESTAUREE
        pause = 0;
}

BIEN ENTENDU, CE CODE N'EST PAS COMPLET, CE SERA A MOI DE TESTER L'ETAT DE LA VARIABLE pause, POUR SAVOIR SI OUI OU NON IL FAUT
EFFECTUER LES CALCULS DE MON JEU.
PAR EX -->
*/

void pause();

int main ( int argc, char** argv )
{
    int continuer=1, mvtHorizontal=0, mvtVertical=0, miseEnPause = 0, largeur = 800, hauteur = 500;
    SDL_Event event;
    SDL_Surface *ecran=NULL, *zozor=NULL;
    SDL_Rect positionZozor;

    if(SDL_Init(SDL_INIT_VIDEO)<0)
    {
        fprintf(stderr,"ERREUR D'INITIALISATION : %s\n", SDL_GetError());
        exit(EXIT_FAILURE);
    }

    SDL_WM_SetIcon(SDL_LoadBMP("images/sdl_icone.bmp"), NULL);
    ecran=SDL_SetVideoMode(largeur, hauteur, 32, SDL_HWSURFACE | SDL_DOUBLEBUF | SDL_RESIZABLE);
    if(ecran==NULL)
    {
        fprintf(stderr, "ERREUR DE CHARGEMENT DU MODE VIDEO :%s\n", SDL_GetError());
        exit(EXIT_FAILURE);
    }
    SDL_WM_SetCaption("Gestion des evenements", NULL);
    SDL_FillRect(ecran, NULL, SDL_MapRGB(ecran->format, 230, 230, 255));
    zozor=SDL_LoadBMP("images/zozor.bmp");
    SDL_SetColorKey(zozor, SDL_SRCCOLORKEY, SDL_MapRGB(zozor->format, 0, 0, 255));
    positionZozor.x = ecran->w / 2 - zozor->w / 2; //J'INITIALISE positionZozor APRES AVOIR CHARGEE LES SURFACES ecran ET zozor
    positionZozor.y = ecran->h / 2 - zozor->h / 2;
    SDL_BlitSurface(zozor, NULL, ecran, &positionZozor);
    SDL_EnableKeyRepeat(10, 10);
    SDL_ShowCursor(SDL_DISABLE);//REF LIGNE 230
    SDL_WarpMouse(ecran->w / 2, ecran->h /2);
    while(continuer)
    {
        SDL_WaitEvent(&event);
        switch(event.type)
        {
            case SDL_QUIT:
                continuer=0;
                break;
            case SDL_KEYDOWN:
                switch(event.key.keysym.sym)
                {
                    case SDLK_UP:
                        positionZozor.y--;
                        break;
                    case SDLK_DOWN:
                        positionZozor.y++;
                        break;
                    case SDLK_RIGHT:
                        positionZozor.x++;
                        break;
                    case SDLK_LEFT:
                        positionZozor.x--;
                        break;
                    case SDLK_SPACE:
                        positionZozor.y-=25;
                        break;
                }
                break;
            case SDL_KEYUP:
                switch(event.key.keysym.sym)
                {
                    case SDLK_SPACE:
                        positionZozor.y+=25;
                        break;
                }
                break;
            case SDL_MOUSEBUTTONUP: // REF LIGNE 185
                if(event.button.button == SDL_BUTTON_RIGHT) //REF LIGNE 200. ON ARRETE LA BOUCLE SI CLIC DROIT DE LA SOURIS
                    continuer=0;
                else if(event.button.button == SDL_BUTTON_LEFT) // ==>déplacer Zozor que si on fait un clic gauche avec la souris
                {
                    positionZozor.x=event.button.x;//REF LIGNE 208
                    positionZozor.y=event.button.y;//REF LIGNE 208
                }
                break;
            case SDL_MOUSEMOTION://REF LIGNE 220
                if(event.motion.x <= (ecran->w - zozor->w))
                    positionZozor.x=event.motion.x;
                if(event.motion.y < (ecran->h - zozor->h))
                    positionZozor.y=event.motion.y;
                break;
            case SDL_VIDEORESIZE: //REF LIGNE 257
                largeur = event.resize.w;
                hauteur = event.resize.h;
                ecran=SDL_SetVideoMode(largeur, hauteur, 32, SDL_HWSURFACE | SDL_DOUBLEBUF | SDL_RESIZABLE);
                positionZozor.x = event.resize.w / 2 - zozor->w / 2;
                positionZozor.y = event.resize.h / 2 - zozor->h / 2;
                break;
            case SDL_ACTIVEEVENT: //REF LIGNE 314
                if((event.active.state & SDL_APPMOUSEFOCUS) == SDL_APPMOUSEFOCUS)
                {
                    if(event.active.gain == 0)
                    {
                        positionZozor.x = ecran->w - zozor->w;
                        positionZozor.y = ecran->h - zozor->h;
                    }
                    else if(event.active.gain == 1)
                        positionZozor.x = 0;
                }
                if((event.active.state & SDL_APPACTIVE) == SDL_APPACTIVE)
                {
                    if(event.active.gain == 0)
                        miseEnPause = 1;
                    else if(event.active.gain == 1)
                        miseEnPause = 0;
                }
                break;


        }
        SDL_FillRect(ecran, NULL, SDL_MapRGB(ecran->format, 230, 230, 255));
        SDL_BlitSurface(zozor, NULL, ecran, &positionZozor);
        SDL_Flip(ecran);

        }
    if(miseEnPause)
        pause();
    SDL_FreeSurface(zozor);
    SDL_Quit();
    return EXIT_SUCCESS;
}

void pause()
{
    int continuer=1;
    SDL_Event event;
    while(continuer)
    {
        SDL_WaitEvent(&event);//RECUPERATION DE L'EVENEMENT DANS event
        switch(event.type)// TEST DU TYPE D'EVENEMENT
        {
            case SDL_QUIT:// SI C'EST UN EVENT DE TYPE "QUITTER"
                continuer=0;
                break;
            case SDL_KEYDOWN://REF LIGNE 93
                switch(event.key.keysym.sym)
                {
                    case SDLK_ESCAPE:// REF LIGNE 107. APPUI SUR LA TOUCHE Echap ==> ARRETER LE PROG
                        continuer=0;
                        break;
                }
                break;
        }
    }
}
