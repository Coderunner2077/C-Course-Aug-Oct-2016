#include <stdlib.h>
#include <stdlib.h>
#include <SDL/SDL.h>
/*
                                                MAITRISER LE TEMPS

I./ LE DELAY ET LES TICKS
SDL_Delay : PERMET DE METTRE EN PAUSE LE PROG UN CERTAIN NB DE MILLISEC
SDL_GetTicks : RETOURNE LE NB DE MILLISEC ECOULEES DEPUIS LE LANCEMENT DU PROG

1.) SDL_Delay

PENDANT QUE LE PROG EST EN PAUSE GRACE A SDL_Delay, ON DIT QU'IL "DORT" : IL N'UTILISE PAS LE PROCESSEUR (abrege : CPU).
DONC C'EST BIEN SI ON VEUT UTILISER LE MOINS DE CPU POSS.
VOICI LE PROTO :
void SDL_Delay(Uint32 ms);
BREF, J'ENVOIE LE NB DE MILLISEC PDT LESQUELS MON PROG DOIT "DORMIR" : ET JE NE POURRAI RIEN FAIRE PDT CE LAPS DE TEMPS!

2.) LE PROBLEME DE LA GRANULARITE DU TEMPS
MON CPU (QUI N'EST PAS DOUBLE COEUR) NE PEUT GERER QU'UN SEUL PROG A LA FOIS. POUR DONNER L'IMPRESSION QUE L'ON PEUT FAIRE
TOURNER PLUSIEURS PROGS EN MM TEMPS, L'OS "DECOUPE" LE TEMPS ET AUTORISE LES PROGS A TRAVAILLER TOUR A TOUR, TEL UN VERITABLE
CHEF D'ORCHESTRE.
OR, CETTE GESTION DU TEMPS ETANT TRES COMPLEXE, IL N'Y A PAS DE GARANTIE QUE L'OS SERA CAPABLE DE REVEILLER MON PROG EXACTEMENT
EN TEMPS VOULUE. ==> UN RETARD DE 10 MS EN MOYENNE.
SDL_Delay EST BIEN PRATIQUE, MAIS IL NE FAUT PAS TROP LUI FAIRE CONFIANCE (A CAUSE DE L'IMPERFECTION DE L'OS).

3.) SDL_GetTicks
PROTO :
Uint32 SDL_GetTicks(void);
LA FCT N'ATTEND AUCUN PAREMETRE, ELLE RENVOIE JUSTE LE NB DE MS ECOULEES DEPUIS LE LANCEMENT DU PROG.

a./ UTILISER SDL_GetTicks POUR GERER LE TEMPS

UN PEU MOINS FACILE D'UTILISATION QUE LE SDL_Delay.
REPRENONS L'EXEMPLE DE ZOZOR (GESTION DES EVENTS) QUI SE DEPLACERA DESORMAIS TOUT SEUL, OU PRESQUE...
JE VAIS AVOIR BESOIN DE 2 VARIABLES tempsActuel ET tempsPrecedent QUI VONT STOCKER LE TMS RETOURNE PAR SDL_GetTicks A DES
MOMENTS DIFFERENTS
VOICI CE QUI SE PASSE:
i.) ON PREND LE TEMPS ACTUEL GRACE A SDL_GetTicks()
ii.)ON COMPARE AU TMS PRECEDEMMENT ENREGISTRE ET S'IL Y A UN ECART DE PLUS DE 30 MS (ET NON PAS EGAL A 30 MS), ALORS...
iii.) ON BOUGE ZOZOR
iv.) ON PLACE LE TEMPS "Actuel" DANS LE TEMPS "Precedent". EN EFFET, AU PROCHAIN TOUR DE BOUCLE, LE TEMPS AURA CHANGE ET JE PEUX
DONC COMPARER LES 2 TEMPS.

b./ UN CHANGEMENT DANS LA GESTION DES EVENTS

LA FCT SDL_WaitEvent N'EST PAS PRATIQUE ICI. EN EFFET, ZOZOR DOIT BOUGER SANS QUE J'AIS A PRODUIRE UN EVENT.
LA SOLUTION --> SDL_PollEvent
CONTRAIREMENT A SDL_WaitEvent, SDL_PollEvent RENVOIE UNE VALEUR QU'IL Y AIT EU UN EVENT OU NON. ELLE N'EST PAS BLOQUANTE.
LA BOUCLE INFINIE VA DONC TOURNER TOUT LE TEMPS (ET UTILISER 100 % DU CPU).

c./ CONSOMMER MOINS DE CPU
LA SOLUTION : SDL_Delay POUR ENDORMIR LE PROG DURANT LE LAPS DE TEMPS OU IL NE DOIT RIEN SE PASSER.

Note : APRES LE if du (tempsActuel - tempsPrecedent > 30), METTRE UN ELSE --> SDL_Delay(30 -(tempsActuel - tempsPrecedent))

d./ CONTROLER LE NB D'IMAGES PAR SEC

COMMENT CONTROLER LE NB D'IMAGES PAR SEC (COURAMMENT ABREGE FPS, "Frames per second")? C'EST CE QUE JE VIENS DE FAIRE!
DANS MON CAS, POUR AVOIR LE NB DE FPS, IL SUFFIT DE DIVISER 1000 (IL Y A 1000 MS DANS UNE SECONDE) PAR 30 :
1000 / 30 = 33 IMAGES PAR SEC ENVIRON. C'EST LARGEMENT SUFFISANT POUR L'OEIL HUMAIN (au moins 25 images par sec necessaires).

II./ LES TIMERS

LES TIMERS CONSTITUENT UNE NOTION UN PEU COMPLEXE QUI FAIT INTERVENIR CE QUE JE N'AI PAS ENCORE VU : LES POINTEURS DE FONCTIONS.
UN TIMER EST UN SYSTEME QUI PERMET DE DEMANDER A LA SDL D'APPELER UNE FONCTION TOUTES LES X MILLISECONDES. JE PEUX AINSI CREER
UNE FCT bougerEnnemi() QUE LA SDL APPELERAIT AUTOMATIQUEMENT TOUTES LES 50 MS AFIN QUE L'ENNEMI SE DEPLACE A INTERVALLES REGULIERS.
CELA EST AUSSI FAISABLE AVEC SDL_GetTicks EN UTILISANT LA TECHNIQUE QUE J'AI VUE PLUS HAUT, MAIS LES TIMERS M'OBLIGENT A MIEUX
STRUCTURER MON PROG DE FCTS.

1.) INITIALISER LE SYSTEME DE TIMERS

POUR POUVOIR UTILISER LES TIMERS JE DOIS D'ABORD INITIALISER LA SDL AVEC UN FLAG SPECIAL :

SDL_INIT_TIMER A RAJOUTER DANS SDL_Init AU DEBUT DU PROG.

2.) AJOUTER UN TIMER

POUR AJOUTER UN TIMER, ON FAIT APPEL A SDL_AddTimer DONT VOICI LE PROTO :

SDL_TimerID SDL_AddTimer(Uint32 interval, SDL_NewTimerCallBack callback, void *param);

NOTE : IL EXISTE EN FAIT DEUX FCTS (QUASIMENT IDENTIQUES) POUR AJOUTER UN TIMER, MAIS L'AUTRE FCT (SDL_SetTimer) EST PLUS
ANCIENNE QUI EXISTE TOUJOURS POUR DES RAISONS DE COMPATIBILITE. J'UTILISERAI DONC SDL_AddTimer ET FAIRE LES CHOSES BIEN.

ON ENVOIE TROIS PARAMETRES A LA FCT :
    -   L'INTERVALLE DE TEMPS (en ms) ENTRE CHAQUE APPEL DE LA FCT
    -   LE NOM DE LA FCT A APPELER. ON APPEL CELA UN CALLBACK. LE PROG SE CHARGE DE RAPPELER CETTE FCT DE CALLBACK REGULIEREMENT
    -   LES PARAMETRES A ENVOYER A MA FONCTION DE CALLBACK

ET OUI, ON N'ENVOIE PAS QUE DES VARIABLES EN PARAMETRE. LES FCTS SONT AUSSI STOCKEES EN MEMOIRE AU CHARGEMENT DU PROG. ELLES ONT
DONC ELLES AUSSI UNE ADRESSE. DU COUP, ON PEUT CREER... DES POINTEURS DE FONCTIONS! IL SUFFIT D'ECRIRE LE NOM DE LA FONCTION
A APPELER POUR INDIQUER L'ADRESSE DE LA FONCTION. AINSI, LA SDL SAURA A QUELLE ADRESSE EN MEMOIRE ELLE DOIT SE RENDRE POUR
APPELER MA FONCTION DE CALLBACK.
SDL_AddTimer RENVOIE UN NUMERO DE TIMER (UN "ID"). JE DOIS STOCKER CE RESULTAT DANS UNE VARIABLE DE TYPE SDL_TimerID. CELA ME
PERMETTRA PAR LA SUITE DE DESACTIVER LE TIMER : IL ME SUFFIRA D'INDIQUER L'ID DU TIMER A ARRETER.
LA SDL ME PERMET D'ACTIVER PLUSIEURS TIMERS EN MEME TEMPS. D'OU L'INTERET DE STOCKER UN ID DE TIMER POUR CHAQUE TIMER POUR POUVOIR
LES DIFFERENCIER.

ON VA DONC CREER UN ID DE TIMER :
SDL_TimerID monTimer;
PUIS JE VAIS CREER MON TIMER:
timer = SDL_AddTimer(30, bougerZozor, &positionZozor)
LE ROLE DE LA FCT bougerZozor SERA DE BOUGER ZOZOR TOUTES LES 30 SEC.

3.) CREATION DE LA FONCTION DE CALLBACK

ATTENTION, MA FONCTION DE CALLBACK DOIT OBLIGATOIREMENT AVOIR LE PROTO SUIVANT :

Uint32 nomDeLaFonction(Uint32 intervalle, void *parametre);

POUR CREER MA FCT bougerZozor, JE DEVRAI DONC ECRIRE LA FCT COMME CECI :

Uint32 bougerZozor(Uint32 intervalle, void *parametre)

CONCERNANT LA FCT bougerZozor :
LA FCT bougerZozor SERA AUTOMATIQUEMENT APPELE TOUTES LES 30 MILLISECONDES.
LA SDL LUI ENVERRA TJS 2 PARAMETRES (ni plus ni moins):
    -   L'INTERVALLE DE TEMPS QUI SEPARERA 2 APPELS DE LA FCT
    -   LE PARAMETRE "PERSONNALISE" QUE J'AI DEMANDE A ENVOYER A LA FCT. ATTENTION, CE PARAMETRE EST UN POINTEUR SUR void; CELA
    SIGNIFIE QUE C'EST UN POINTEUR QUI PEUT POINTER SUR N'IMPORTE QUOI.
    REMARQUE : JE NE PEUX ENVOYER QU'UN SEUL PARAMETRE PERSONNALISE A LA FCT DE CALLBACK. HEUREUSEMENT, JE PEUX TOUJOURS CREER
    UN TYPE PERSONNALISE (OU UN TABLEAU) QUI SERA UN ASSEMBLAGE DE VARIABLES QUE JE VEUX TRANSMETTRE.

L'INTERET DE CREER UN DEUXIEME POINTEUR QUI CONTIENT LA MEME ADRESSE QUE void *paremetre EST PRIMORDIAL A COMPRENDRE :
==> JE PEUX AINSI ACCEDER A DES SOUS-VARIABLES (positionzZozor->x, positionZozor->y) QUI NE SONT PAS CONTENUS DANS void* EN TANT
QUE TEL (LE COMPILATEUR LES AURAIT REJETES EN BLOC).

DERNIERE CHOSE, TRES IMPORTANTE, JE DOIS RETOURNER LA VARIABLE INTERVALLE. CELA INDIQUERA A LA SDL QU'ON VEUT CONTINUER A FAIRE
EN SORTE QUE LA FCT SOIT APPELEE TOUTES LES 30 MS. SI JE SOUHAITE CHANGER L'INTERVALLE D'APPEL, IL SUFFIT DE RENVOYER UNE AUTRE
VALEUR (MAIS BIEN SOUVENT, ON CHANGE PAS CET INTERVALLE).

4.) ARRETER LE TIMER

C'EST TRES SIMPLE :

SDL_RemoveTimer(monTimer);

IL SUFFIT D'APPELER SDL_RemoveTimer EN INDIQUANT L'ID DU TIMER. ICI, J'ARRETERAI LE TIMER JUSTE APRES LA BOUCLE INFINIE, AU
MEME ENDROIT QUE LES SDL_FreeSurface.

REMARQUE : IMPOSSIBLE DE FAIRE FAIRE DES CHOSES DIFFERENTES AVEC LE TIMER (PAR EXEMPLE FAIRE CHANGER DE SENS). AUTRE CHOSE, IL
SEMBLE QUE LA FONCTION DE CALLBACK EST APPELEE BCP PLUS FREQUEMMENT QUE L'INTERVALLE DE TEMPS ENVOYE EN PARAMETRE
 !!!!! --> IL NE FAUT PAS PLACER LE TIMER DANS LA BOUCLE PRINCIPALE
*/
Uint32 bougerZozorADroite(Uint32 intervalle, void *parametre);
Uint32 bougerZozorAGauche(Uint32 intervalle, void *parametre);

int main ( int argc, char** argv )
{
    SDL_Surface *ecran = NULL, *zozor = NULL;
    SDL_Rect pos;
    SDL_Event event;
    SDL_TimerID monTimer; // VARIABLE POUR STOCKER LE NUMERO DE TIMER // REF LIGNE 101
    SDL_TimerID timer;
    Uint32 tempsActuel = 0, tempsPrecedent = 0;
    int continuer = 1, versLaDroite = 1, enHaut = 1, pause = 0;
    SDL_Init(SDL_INIT_VIDEO | SDL_INIT_TIMER); // REF LIGNE 75
    ecran = SDL_SetVideoMode(600, 480, 32, SDL_HWSURFACE | SDL_DOUBLEBUF);
    SDL_WM_SetCaption("Zozor bouge ti seul", NULL);
    zozor = SDL_LoadBMP("zozor.bmp");
    SDL_SetColorKey(zozor, SDL_SRCCOLORKEY, SDL_MapRGB(zozor->format, 0, 0, 255));
    pos.x = ecran->w / 2 - zozor->w / 2;
    pos.y = ecran->h / 2 - zozor->h / 2;

    //monTimer = SDL_AddTimer(30, bougerZozorADroite, &pos); // demarrage du timer // REF LIGNE 114
    while(continuer)
    {
        SDL_PollEvent(&event); //On utilise PollEvent et non WaitEvent pour ne pas bloquer le programme
        switch(event.type)
        {
            case SDL_QUIT:
                continuer = 0;
                break;
            case SDL_KEYDOWN:
                switch(event.key.keysym.sym)
                {
                    case SDLK_p:
                        pause = 1;
                        break;
                    case SDLK_SPACE:
                        pause = 0;
                        break;
                }
                break;
        }

        if(pos.x >= ecran->w - zozor->w)
            versLaDroite = 0;
        else if(pos.x == 0)
            versLaDroite = 1;
        if(pos.y == ecran->h - zozor->h)
            enHaut = 1;
        else if(pos.y == 0)
            enHaut = 0;

        if(!pause)
        {
        tempsActuel = SDL_GetTicks();//REF LIGNE 35
        if(tempsActuel - tempsPrecedent > 15)//SI 30 MS SE SONT ECOULEES
        {
            tempsPrecedent = tempsActuel;  // LE TEMPS "ACTUEL" DEVIENT LE TEMPS "PRECEDENT" POUR MES FUTURS CALCULS
            if(versLaDroite)
            {
                pos.x++;//ALORS ON BOUGE ZOZOR
            }
            else
                pos.x--;
            if(enHaut)
                pos.y--;
            else
                pos.y++;
        }
        else //SI CELA FAIT MOINS DE 30 MS DEPUIS LE DERNIER TOUR DE BOUCLE, ON ENDORT LE PROG LE TMS QU'IL FO
            SDL_Delay(15 - (tempsActuel - tempsPrecedent)); //REF LIGNE 53
        }



        SDL_FillRect(ecran, NULL, SDL_MapRGB(ecran->format, 255, 255, 255));
        SDL_BlitSurface(zozor, NULL, ecran, &pos);
        SDL_Flip(ecran);
        }
        SDL_FreeSurface(zozor);
        SDL_RemoveTimer(monTimer);//REF LIGNE 137
        SDL_RemoveTimer(timer);
        SDL_Quit();

        return EXIT_SUCCESS;
    }
    //FONCTION DE CALLBACK (SERA APPELE TOUTES LES 30 MS)
    Uint32 bougerZozorADroite(Uint32 intervalle, void *parametre) // REF LIGNE 114
    {
        SDL_Rect *positionZozor = parametre;//CONVERSION DE void* EN SDL_Rect*
        positionZozor->x++; //JE MODIFIE LA POSITION DE ZOZOR A L'AIDE DU POINTEUR

        return intervalle;
    }

    Uint32 bougerZozorAGauche(Uint32 intervalle, void *parametre) // REF LIGNE 114
    {
        SDL_Rect *positionZozor = parametre;//CONVERSION DE void* EN SDL_Rect*

        positionZozor->x--; //JE MODIFIE...

        return intervalle;
    }
